### Java类加载的顺序
* 父类的静态代码块
* 子类的静态代码块
* 初始化父类的属性值/父类的普通代码块(自上而下的顺序排列)
* 父类的构造方法
* 初始化子类的属性值/子类的普通代码块(自上而下的顺序排列)
* 子类的构造方法
* 构造函数最后执行
##### 静态资源在类的初始化中只会执行一次

##### 方法的调用,伴随着栈帧的入栈和出栈
##### 栈帧中主要保存:本地变量,记录栈操作,栈帧数据(类文件,方法)
##### 类定义数据,常量,静态变量,JIT编译后的代码 存储在方法区
##### 运行时常量池(用于存储编译期产生的字面量和符号引用,运行时产生的新常量可以被放入常量池)存储在方法区
##### 常量池包括:基本类型,对象型的常量值,类和接口的全限定名,字段的名称和描述符,方法和名称的描述符

#### GC Roots对象
* 虚拟机栈的栈帧的局部变量表所引用的对象
* 本地方法栈的JNI所引用的对象
* 方法区的静态变量和常量所引用的对象

#### Java在new一个对象的时候,会先查看对象所属的类有没有被加载到内存,没有的话,就会先通过类的全限定名来加载,加载并初始化类完成后,再进行对象的创建工作

#### 双亲委派机制的好处:能够有效确保一个类的全局唯一性,当程序中出现多个限定名相同的类时,类加载器在执行加载时,始终只会加载其中的某一个类

### SOA的主要特性
* 面向服务的分布式计算
* 服务间松散耦合
* 支持服务的组装
* 服务注册和自动发现
* 以服务契约方式定义服务交互方式


#### Mapper定义的接口,如何实现
* Mapper接口在初始SqlSessionFactory注册的
* Mapper接口注册在名为MapperRegistry类的HashMap中,key=Mapper class对象;value=创建当前Mapper的工厂
* Mapper注册之后,可以从SqlSession中get到Mapper
* SqlSession.getMapper运用了JDK动态代理,产生了目标Mapper接口的代理对象
* 动态代理的代理类是MapperProxy,这里边最终完成了增删改查的调用


### 用户进程申请并访问物理内存的过程
* 用户进程向操作系统发出内存申请请求
* 系统会检查进程的虚拟地址空间是否被用完,如果有剩余,给进程分配虚拟地址
* 系统为这块虚拟地址创建内存映射(Memory Mapping),并将它放进该进程的页表(Page Table)
* 系统返回虚拟地址给用户进程,用户进程开始访问该虚拟地址
* CPU根据虚拟地址在此进程的页表(Page Table)中找到相应的内存映射(Memory Mapping),但是这个内存映射(Memory Mapping)没有和物理内存关联,于是产生缺页中端
* 操作系统收到缺页中断后,分配真正的屋里内存并将它关联到页表相应的内存映射(Memory Mapping),中断处理完成后,CPU就可以访问内存了
* 缺页中断不是每次都会发生,只有系统觉得有必要延迟分配内存的时候才用的到,也即很多时候在上面的第3步系统会分配真正的物理内存并和内存映射关联

#### 进程私有的虚拟内存:每个进程都有单独的内核栈,页表,task结构以及mem_map结构等
#### 进程共享的虚拟内存:属于所有进程共享的内存区域,包括物理存储器,内核数据和内核代码区域

#### I/O中断原理:
* 用户进程向CPU发起read系统调用读取数据,由用户态切换为内核态,然后一直阻塞等待数据的返回
* CPU在接收到指令以后对磁盘发起I/O请求,将磁盘数据先放入磁盘控制器缓冲区
* 数据准备完成以后,磁盘向CPU发起I/O中断
* CPU收到I/O中断以后将磁盘缓冲区中的数据拷贝到内核缓冲区,然后再从内核缓冲区拷贝到用户缓冲区
* 用户进程由内核态切换回用户态,解除阻塞状态,然后等待CPU的下一个执行时间钟

